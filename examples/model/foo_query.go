// generated by sqlgen -type=Foo; DO NOT EDIT

package model

import "database/sql"
import "time"

type FooQuery struct {
	db        *sql.DB
	create    *sql.Stmt
	byId      *sql.Stmt
	byBar     *sql.Stmt
	byBaz     *sql.Stmt
	byCreated *sql.Stmt
}
type FooQueryTxn struct {
	tx *sql.Tx
	q  *FooQuery
}

func NewFooQuery(db *sql.DB) (*FooQuery, error) {
	q := &FooQuery{db: db}
	if err := q.Validate(); err != nil {
		return nil, err
	}
	return q, nil
}
func (q *FooQuery) Validate() error {
	if stmt, err := q.db.Prepare("INSERT INTO foo(id,bar,baz,created) VALUES($1,$2,$3,$4)"); err != nil {
		return err
	} else {
		q.create = stmt
	}
	if stmt, err := q.db.Prepare("SELECT id,bar,baz,created FROM foo WHERE id = $1;"); err != nil {
		return err
	} else {
		q.byId = stmt
	}
	if stmt, err := q.db.Prepare("SELECT id,bar,baz,created FROM foo WHERE bar = $1;"); err != nil {
		return err
	} else {
		q.byBar = stmt
	}
	if stmt, err := q.db.Prepare("SELECT id,bar,baz,created FROM foo WHERE baz = $1;"); err != nil {
		return err
	} else {
		q.byBaz = stmt
	}
	if stmt, err := q.db.Prepare("SELECT id,bar,baz,created FROM foo WHERE created = $1;"); err != nil {
		return err
	} else {
		q.byCreated = stmt
	}
	return nil
}
func (q *FooQuery) Transaction() (*FooQueryTxn, error) {
	if tx, err := q.db.Begin(); err != nil {
		return nil, err
	} else {
		return &FooQueryTxn{tx: tx, q: q}, nil
	}
}
func (tq *FooQueryTxn) Create(obj Foo) error {
	return nil
}
func (tq *FooQueryTxn) ById(Id int64) (*Foo, error) {
	row := tq.tx.Stmt(tq.q.byId).QueryRow(Id)
	obj := new(Foo)
	if err := row.Scan(&obj.Id, &obj.Bar, &obj.Baz, &obj.Created); err != nil {
		return nil, err
	}
	return obj, nil
}
func (tq *FooQueryTxn) ByBar(Bar string) (<-chan *Foo, <-chan error) {
	objChan := make(chan *Foo, 10)
	errChan := make(chan error, 10)
	if rows, err := tq.tx.Stmt(tq.q.byBar).Query(Bar); err != nil {
		errChan <- err
	} else {
		go func() {
			defer close(objChan)
			defer close(errChan)

			for rows.Next() {
				obj := new(Foo)
				if err := rows.Scan(&obj.Id, &obj.Bar, &obj.Baz, &obj.Created); err != nil {
					errChan <- err
					break
				} else {
					objChan <- obj
				}
			}
		}()
	}
	return objChan, errChan
}
func (tq *FooQueryTxn) ByBaz(Baz string) (<-chan *Foo, <-chan error) {
	objChan := make(chan *Foo, 10)
	errChan := make(chan error, 10)
	if rows, err := tq.tx.Stmt(tq.q.byBaz).Query(Baz); err != nil {
		errChan <- err
	} else {
		go func() {
			defer close(objChan)
			defer close(errChan)

			for rows.Next() {
				obj := new(Foo)
				if err := rows.Scan(&obj.Id, &obj.Bar, &obj.Baz, &obj.Created); err != nil {
					errChan <- err
					break
				} else {
					objChan <- obj
				}
			}
		}()
	}
	return objChan, errChan
}
func (tq *FooQueryTxn) ByCreated(Created time.Time) (<-chan *Foo, <-chan error) {
	objChan := make(chan *Foo, 10)
	errChan := make(chan error, 10)
	if rows, err := tq.tx.Stmt(tq.q.byCreated).Query(Created); err != nil {
		errChan <- err
	} else {
		go func() {
			defer close(objChan)
			defer close(errChan)

			for rows.Next() {
				obj := new(Foo)
				if err := rows.Scan(&obj.Id, &obj.Bar, &obj.Baz, &obj.Created); err != nil {
					errChan <- err
					break
				} else {
					objChan <- obj
				}
			}
		}()
	}
	return objChan, errChan
}
